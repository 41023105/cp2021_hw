var tipuesearch = {"pages": [{'title': 'About', 'text': '這是計算機程式課程 2021 Fall 的作業倉儲與網站 template \n \n 41023105 \n 網站倉儲:\xa0 https://github.com/41023105/cp2021_hw \xa0 \n 網站連結:\xa0 https://41023105.github.io/cp2021_hw/ \n 其他與個人或作業相關資料說明或介紹 \n', 'tags': '', 'url': 'About.html'}, {'title': 'run', 'text': ' 導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  Filename:  .py    存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n', 'tags': '', 'url': 'run.html'}, {'title': 'Exam', 'text': '', 'tags': '', 'url': 'Exam.html'}, {'title': 'w13', 'text': '\n 列出10座標 \n \n  導入 brython 程式庫  \n \n \n  啟動 Brython  \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  內建程式 1 ####################################### 內建程式 1 開始 \n \n \n \n  內建程式 1 ####################################### 內建程式 1 結束 \n \n  button 程式 1 ####################################### button 程式 1 開始 \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n \n  editor1 結束  \n', 'tags': '', 'url': 'w13.html'}, {'title': 'HW1', 'text': 'HW1 - 網際動畫與 touch typing 佔學期成績 20%. \n HW1 必須在 2021.10.20 22:00 之前完成 . \n HW1 具體項目成果回報區 將於 2021.09.23 開啟, 於  2021.10.20 22:00 關閉 \n \n 請至  https://github.com  申請 Github 帳號後, 至  https://mde.tw/cp2021/content/Task1.html \xa0 頁面, 將左右碰撞移動的紅色方塊, 改為先移動到水平畫面中心點位置後, 接著上下碰撞移動. \n 請將 1. 的程式碼存入個人 Gist 區 ( 說明 ). \n 請在 1. 的程式中, 加入與  Cango 頁面  Fourbar 程式碼相同功能的啟動按鈕, 讓使用者可以利用按鈕啟動或中斷紅色方塊上下碰撞移動. 完成後請將程式碼存入個人 Gist 區. \n 請在 Gist 檔案編輯區, 利用鍵盤輸入  https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists#about-gists  中的這段英文內容, 請利用手機計時, 大概需要多少時間? 請將此段練習打字的內容與所需時間存入 Gist 檔案中. \n 請至少練習 key in 這段英文內容三次, 然後看看是否已經了解如何透過電腦鍵盤 touch typing? \n 接下來請利用中文輸入  https://ithelp.ithome.com.tw/articles/10206233  的第一段中文說明, 請利用手機計時, 大概需要多少時間? \n \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 - 可攜程式系統與個人網站佔學期成績 20%. \n HW2 必須在 2021.11.03 22:00 之前完成. \n HW2 具體項目成果回報區 將於 2021.10.25 開啟, 於  2021.11.03 22:00 關閉 \n 可攜程式系統與 Python 範例程式收集整理 \n 1. 請準備一個至少 64 GB 大小的 USB 3.0 以上隨身碟 (或外接 SSD), 根據  Task2  中的說明, 建立自己的可攜程式系統.\xa0 \n 2. 請登入 Github 帳號後, 連線至  https://github.com/mdecourse/cp2021_hw  後, 透過  Use this template  按鈕建立自己的 cp2021_hw 倉儲. 並至該倉儲的 Settings -> Pages -> Source 將 main 分支設為 Github Pages 的 root (也就是選擇將倉儲的 main 分支設為對應網站的根目錄). \n 3. 請將 HW1 與 HW2 的作業內容登錄至個人的 cp2021_hw 倉儲與網站中. (學習如何透過 git 指令修改倉儲中的版本內容) \n 4. 請在個人作業網站的 HW2 區域下增設一個 H2 頁面, 將該網頁標題命名為 run, 可以如  run  頁面中的內容, 並且利用此頁面收集 Python 範例程式. (例如: 可自動執行的貪食蛇:  https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/d306a1f57e53bfd6466eaae20bcb9439/raw/2160a12b9fec9707a120a383ed5d38b9b78a02cf/snake.py  將  https://gist.github.com/mdecourse/d306a1f57e53bfd6466eaae20bcb9439  作為  https://mde.tw/cp2021/content/run.html  頁面中 src 變數的值, 就可以在頁面中導入程式碼並執行) \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': '\n HW3 - AI 貪食蛇佔學期成績 30%. \n HW3 必須在 2021.12.22 22:00 之前完成. \n HW3 具體項目成果回報區 將於 2021.11.09 開啟, 於  2021.12.22 22:00 關閉 \n 網際貪食蛇的逆襲, 誰的 自動執行貪食蛇 能夠破紀錄? 目前直覺貪食蛇紀錄為 45 節 (除了蛇身節數外, 應該還要置入出現紅色標的物後的總完食時間). \n 手動執行貪食蛇 程式說明與整理. \n 自動執行貪食蛇 程式說明與整理. \n 自動執行貪食蛇 程式的改進. \n 參考資料: \n https://mde.tw/cp2021/content/Task3.html \n Brython snake 原始來源:  https://medium.com/swlh/sick-of-javascript-just-use-browser-python-4b9679efe08b \n https://github.com/mdecourse/snake-Q-Learning \n https://towardsdatascience.com/teaching-a-computer-how-to-play-snake-with-q-learning-93d0a316ddc0 \n https://github.com/mdecourse/SnakeQlearning \n https://medium.com/@italohdc/learnsnake-teaching-an-ai-to-play-snake-using-reinforcement-learning-q-learning-b63ac23dfdd1 \n https://towardsdatascience.com/snake-played-by-a-deep-reinforcement-learning-agent-53f2c4331d36 \n https://www.geeksforgeeks.org/ai-driven-snake-game-using-deep-q-learning/ \n https://www3.hs-albsig.de/wordpress/point2pointmotion/2020/10/09/deep-reinforcement-learning-with-the-snake-game/ \n 2016_Exploration of Reinforcement Learning to SNAKE.pdf \n train_a_snake_with_reinforceme.pdf \n https://medium.com/@hugo.sjoberg88/using-reinforcement-learning-and-q-learning-to-play-snake-28423dd49e9b \n https://github.com/mdecourse/Snake-Reinforcement-Learning \n Autonomous-Agents-in-Snake-Game-via-Deep-Reinforcement-Learning.pdf \n 延伸應用: \n \n \n \n \n https://github.com/mdecourse/snake-ai-pytorch \n \n \n \n \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'BSnke', 'text': ' 導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  印出版次與關鍵字程式  \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n # coding: utf-8\n\nimport curses\nfrom curses import KEY_RIGHT, KEY_LEFT, KEY_UP, KEY_DOWN\nfrom random import randint\n\n# 蛇运动的场地长宽\nHEIGHT = 10\nWIDTH = 20\nFIELD_SIZE = HEIGHT * WIDTH\n\n# 蛇头总是位于snake数组的第一个元素\nHEAD = 0\n\n# 用来代表不同东西的数字，由于矩阵上每个格子会处理成到达食物的路径长度，\n# 因此这三个变量间需要有足够大的间隔(>HEIGHT*WIDTH)\nFOOD = 0\nUNDEFINED = (HEIGHT + 1) * (WIDTH + 1)\nSNAKE = 2 * UNDEFINED\n\n# 由于snake是一维数组，所以对应元素直接加上以下值就表示向四个方向移动\nLEFT = -1\nRIGHT = 1\nUP = -WIDTH\nDOWN = WIDTH\n\n# 错误码\nERR = -1111\n\n# 用一维数组来表示二维的东西\n# board表示蛇运动的矩形场地\n# 初始化蛇头在(1,1)的地方，第0行，HEIGHT行，第0列，WIDTH列为围墙，不可用\n# 初始蛇长度为1\nboard = [0] * FIELD_SIZE\nsnake = [0] * (FIELD_SIZE+1)\nsnake[HEAD] = 1*WIDTH+1\nsnake_size = 1\n# 与上面变量对应的临时变量，蛇试探性地移动时使用\ntmpboard = [0] * FIELD_SIZE\ntmpsnake = [0] * (FIELD_SIZE+1)\ntmpsnake[HEAD] = 1*WIDTH+1\ntmpsnake_size = 1\n\n# food:食物位置(0~FIELD_SIZE-1),初始在(3, 3)\n# best_move: 运动方向\nfood = 3 * WIDTH + 3\nbest_move = ERR\n\n# 运动方向数组\nmov = [LEFT, RIGHT, UP, DOWN]\n# 接收到的键 和 分数\nkey = KEY_RIGHT                                                    \nscore = 1 #分数也表示蛇长\n\n# 检查一个cell有没有被蛇身覆盖，没有覆盖则为free，返回true\ndef is_cell_free(idx, psize, psnake):\n    #return not (idx in psnake[:]) #错！psnake后面还有很多没用上的单元\n    for i in xrange(psize):\n        if idx == psnake[i]: return False\n    return True\n    \n\n# 检查某个位置idx是否可向move方向运动\ndef is_move_possible(idx, move):\n    flag = False\n    if move == LEFT:\n        flag = True if idx%WIDTH > 1 else False\n    elif move == RIGHT:\n        flag = True if idx%WIDTH < (WIDTH-2) else False\n    elif move == UP:\n        flag = True if idx > (2*WIDTH-1) else False # 即idx/WIDTH > 1\n    elif move == DOWN:\n        flag = True if idx < (FIELD_SIZE-2*WIDTH) else False # 即idx/WIDTH < HEIGHT-2\n    return flag\n# 重置board\n# board_refresh后，UNDEFINED值都变为了到达食物的路径长度\n# 如需要还原，则要重置它\ndef board_reset(psnake, psize, pboard):\n    for i in xrange(FIELD_SIZE):\n       # f.write(\'hello \' + str(len(pboard)) +\' \' +str(i)+\'\\n\')\n        if i == food:\n            pboard[i] = FOOD\n        elif is_cell_free(i, psize, psnake): # 该位置为空\n            pboard[i] = UNDEFINED\n        else: # 该位置为蛇身\n            pboard[i] = SNAKE\n    \n# def board_refresh(pfood, psnake, pboard):\n#     board_changed = True\n#     found = False\n#     while board_changed: # 一直更新board，直到每个格子上的数都对应到达食物的步数，不能再改变为止\n#         board_changed = False\n#         for i in xrange(FIELD_SIZE):\n#             if pboard[i] < SNAKE: \n#                 min = pboard[i]\n#                 for j in xrange(4):\n#                     if is_move_possible(i, mov[j]) and pboard[i+mov[j]] < min:\n#                         min = pboard[i+mov[j]]\n#                 if pboard[i] > min+1:\n#                     pboard[i] = min + 1\n#                     board_changed = True\n\n#         if ~board_changed: break # 不再改变，退出\n#         board_changed = False\n\n#         for i in xrange(FIELD_SIZE-1, -1, -1): # [FIELD_SIZE-1, 0]\n#             if pboard[i] < SNAKE:\n#                 min = pboard[i]\n#                 for j in xrange(4):\n#                     if is_move_possible(i, mov[j]) and pboard[i+mov[j]] < min:\n#                         min = pboard[i+mov[j]]\n#                 if pboard[i] > min+1:\n#                     pboard[i] = min + 1\n#                     board_changed = True\n#     for i in xrange(4):\n#         if is_move_possible(psnake[HEAD], mov[i]) and pboard[psnake[HEAD]+mov[i]]<UNDEFINED:\n#             flag = True\n\n#     return flag\n\n# 广度优先搜索遍历整个board，\n# 计算出board中每个非SNAKE元素到达食物的路径长度\ndef board_refresh(pfood, psnake, pboard):\n    queue = []\n    queue.append(pfood)\n    inqueue = [0] * FIELD_SIZE\n    found = False\n    # while循环结束后，除了蛇的身体，\n    # 其它每个方格中的数字代码从它到食物的路径长度\n    #f.write(\'bfs begin:\\n\')\n    while len(queue)!=0: \n        idx = queue.pop(0)\n        if inqueue[idx] == 1: continue\n        #f.write(str(idx)+\'\\n\')\n        inqueue[idx] = 1\n        for i in xrange(4):\n            if is_move_possible(idx, mov[i]):\n                if idx + mov[i] == psnake[HEAD]:\n                    found = True\n                if pboard[idx+mov[i]] < SNAKE: # 如果该点不是蛇的身体\n                    \n                    if pboard[idx+mov[i]] > pboard[idx]+1:\n                        pboard[idx+mov[i]] = pboard[idx] + 1\n                    if inqueue[idx+mov[i]] == 0:\n                        queue.append(idx+mov[i])\n\n    #f.write(\'bfs end\\n\')\n    #f.write(\'found: \' + str(found) +\'\\n\')\n    return found\n\n# 从蛇头开始，根据board中元素值，\n# 从蛇头周围4个领域点中选择最短路径\ndef choose_shortest_safe_move(psnake, pboard):\n    best_move = ERR\n    min = SNAKE\n    for i in xrange(4):\n        if is_move_possible(psnake[HEAD], mov[i]) and pboard[psnake[HEAD]+mov[i]]<min:\n            min = pboard[psnake[HEAD]+mov[i]]\n            best_move = mov[i]\n    return best_move\n\n# 从蛇头开始，根据board中元素值，\n# 从蛇头周围4个领域点中选择最远路径\ndef choose_longest_safe_move(psnake, pboard):\n    best_move = ERR\n    max = -1\n    for i in xrange(4):\n        if is_move_possible(psnake[HEAD], mov[i]) and pboard[psnake[HEAD]+mov[i]]<UNDEFINED and pboard[psnake[HEAD]+mov[i]]>max:\n            max = pboard[psnake[HEAD]+mov[i]]\n            best_move = mov[i]\n    return best_move\n\n# 检查是否可以追着蛇尾运动，即蛇头和蛇尾间是有路径的\n# 为的是避免蛇头陷入死路\n# 虚拟操作，在tmpboard,tmpsnake中进行\ndef is_tail_inside():\n    global tmpboard, tmpsnake, food, tmpsnake_size\n    tmpboard[tmpsnake[tmpsnake_size-1]] = 0 # 虚拟地将蛇尾变为食物(因为是虚拟的，所以在tmpsnake,tmpboard中进行)\n    tmpboard[food] = SNAKE # 放置食物的地方，看成蛇身\n    result = board_refresh(tmpsnake[tmpsnake_size-1], tmpsnake, tmpboard) # 求得每个位置到蛇尾的路径长度\n    for i in xrange(4): # 如果蛇头和蛇尾紧挨着，则返回False。即不能follow_tail，追着蛇尾运动了\n        if is_move_possible(tmpsnake[HEAD], mov[i]) and tmpsnake[HEAD]+mov[i]==tmpsnake[tmpsnake_size-1] and tmpsnake_size>3:\n            result = False\n    return result\n\n# 让蛇头朝着蛇尾运行一步\n# 不管蛇身阻挡，朝蛇尾方向运行\ndef follow_tail():\n    global tmpboard, tmpsnake, food, tmpsnake_size\n    tmpsnake_size = snake_size\n    tmpsnake = snake[:]\n    board_reset(tmpsnake, tmpsnake_size, tmpboard) # 重置虚拟board\n    tmpboard[tmpsnake[tmpsnake_size-1]] = FOOD # 让蛇尾成为食物\n    tmpboard[food] = SNAKE # 让食物的地方变成蛇身\n    board_refresh(tmpsnake[tmpsnake_size-1], tmpsnake, tmpboard) # 求得各个位置到达蛇尾的路径长度\n    tmpboard[tmpsnake[tmpsnake_size-1]] = SNAKE # 还原蛇尾\n\n    # return choose_longest_safe_move(tmpsnake, tmpboard) # 返回运行方向(让蛇头运动1步)\n    return choose_longest_safe_move(tmpsnake, tmpboard)\n\n# 在各种方案都不行时，随便找一个可行的方向来走(1步),\ndef any_possible_move():\n    global food , snake, snake_size, board\n    best_move = ERR\n    board_reset(snake, snake_size, board)\n    board_refresh(food, snake, board)\n    min = SNAKE\n\n    for i in xrange(4):\n        if is_move_possible(snake[HEAD], mov[i]) and board[snake[HEAD]+mov[i]]<min:\n            min = board[snake[HEAD]+mov[i]]\n            best_move = mov[i]\n    return best_move\n\ndef shift_array(arr, size):\n    for i in xrange(size, 0, -1):\n        arr[i] = arr[i-1]\n\ndef new_food():\n    global food, snake_size\n    if snake_size >= FIELD_SIZE-1: return\n    cell_free = False\n    while not cell_free:\n        w = randint(1, WIDTH-2)\n        h = randint(1, HEIGHT-2)\n        food = h * WIDTH + w\n        cell_free = is_cell_free(food, snake_size, snake)\n    win.addch(food/WIDTH, food%WIDTH, \'@\')\n\n# 真正的蛇在这个函数中，朝pbest_move走1步\ndef make_move(pbest_move):\n    global key, snake, board, snake_size, score\n    shift_array(snake, snake_size)\n    snake[HEAD] += pbest_move\n    \n\n    # 按esc退出，getch同时保证绘图的流畅性，没有它只会看到最终结果\n    win.timeout(10)\n    event = win.getch()\n    key = key if event == -1 else event\n    if key == 27: return\n\n    p = snake[HEAD]\n    win.addch(p/WIDTH, p%WIDTH, \'*\')\n\n    \n    # 如果新加入的蛇头就是食物的位置\n    # 蛇长加1，产生新的食物，重置board(因为原来那些路径长度已经用不上了)\n    if snake[HEAD] == food:\n        board[snake[HEAD]] = SNAKE # 新的蛇头\n        snake_size += 1\n        score += 1\n        if snake_size < FIELD_SIZE: new_food()\n        #board_reset(snake, board) # \n        #return True\n    else: # 如果新加入的蛇头不是食物的位置\n        board[snake[HEAD]] = SNAKE # 新的蛇头\n        board[snake[snake_size]] = UNDEFINED # 蛇尾变为空格\n        win.addch(snake[snake_size]/WIDTH, snake[snake_size]%WIDTH, \' \')\n        #return False\n    # test 打印tmpboard\n    for i in xrange(HEIGHT):\n        for j in xrange(WIDTH):\n            k = board[i*WIDTH+j]\n            f.write(str(k)+\' \')\n        f.write(\'\\n\')\n    # print symbol\n    for i in xrange(HEIGHT):\n        for j in xrange(WIDTH):\n            k = board[i*WIDTH+j]\n            if k == UNDEFINED:\n                f.write(\'# \')\n            elif k == SNAKE:\n                if i*WIDTH+j == snake[HEAD]:\n                    f.write(\'+ \') # 蛇头\n                elif i*WIDTH+j == snake[snake_size-1]:\n                    f.write(\'- \') # 蛇尾\n                else:\n                    f.write(\'* \')\n            else:\n                f.write(str(k)+\' \')\n        f.write(\'\\n\')\n    f.write(\'\\n\')\n\n# 虚拟地运行一次，然后在调用处检查这次运行可否可行\n# 可行才真实运行。\n# 虚拟运行吃到食物后，得到虚拟下蛇在board的位置\ndef virtual_shortest_move():\n    global snake, board, snake_size, tmpsnake, tmpboard, tmpsnake_size, food\n    #f.write(\'i am in virtual\\n\')\n    tmpsnake_size = snake_size\n    tmpsnake = snake[:] # 如果直接tmpsnake=snake，则两者指向同一处内存\n    tmpboard = board[:] # board中已经是各位置到达食物的路径长度了，不用再计算\n    board_reset(tmpsnake, tmpsnake_size, tmpboard)\n    \n\n    # test 打印tmpboard\n    # for i in xrange(HEIGHT):\n    #     for j in xrange(WIDTH):\n    #         k = tmpboard[i*WIDTH+j]\n    #         f.write(str(k)+\' \')\n    #     f.write(\'\\n\')\n    \n    food_eated = False\n    while not food_eated:\n        board_refresh(food, tmpsnake, tmpboard)    \n        move = choose_shortest_safe_move(tmpsnake, tmpboard)\n        shift_array(tmpsnake, tmpsnake_size)\n        tmpsnake[HEAD] += move # 在蛇头前加入一个新的位置\n        #f.write(\'snake head: \'+str(tmpsnake[HEAD])+\'\\n\')\n        # 如果新加入的蛇头的位置正好是食物的位置\n        # 则长度加1，重置board，食物那个位置变为蛇的一部分(SNAKE)\n        if tmpsnake[HEAD] == food:\n            tmpsnake_size += 1\n            board_reset(tmpsnake, tmpsnake_size, tmpboard) # 虚拟运行后，蛇在board的位置(label101010)\n            tmpboard[food] = SNAKE\n            food_eated = True\n        else: # 如果蛇头不是食物的位置，则新加入的位置为蛇头，最后一个变为空格\n            tmpboard[tmpsnake[HEAD]] = SNAKE\n            tmpboard[tmpsnake[tmpsnake_size]] = UNDEFINED\n    #f.write(\'i am out virtual\\n\')\n\n# 如果蛇与食物间有路径，则调用本函数\ndef find_safe_way():\n    global snake, board\n    safe_move = ERR\n    # 虚拟地运行一次，因为已经确保蛇与食物间有路径，所以执行有效\n    # 运行后得到虚拟下蛇在board中的位置，即tmpboard，见label101010\n    virtual_shortest_move() # 该函数唯一调用处\n    if is_tail_inside(): # 如果虚拟运行后，蛇头蛇尾间有通路，则选最短路运行(1步)\n        return choose_shortest_safe_move(snake, board)\n    safe_move = follow_tail() # 否则虚拟地follow_tail 1步，如果可以做到，返回true\n    return safe_move\n\n\ncurses.initscr()\nwin = curses.newwin(HEIGHT, WIDTH, 0, 0)\nwin.keypad(1)\ncurses.noecho()\ncurses.curs_set(0)\nwin.border(0)\nwin.nodelay(1)\nwin.addch(food/WIDTH, food%WIDTH, \'@\')\n\nf = file(\'log\', \'w\')\n    \nwhile key != 27:\n    win.border(0)\n    win.addstr(0, 2, \'s:\' + str(score) + \' \')               \n    #win.addstr(0, WIDTH/2-3, \' SNAKE \')                                  \n    win.timeout(10)\n    # 接收键盘输入，同时也使显示流畅\n    event = win.getch()\n    key = key if event == -1 else event\n    if snake_size >= FIELD_SIZE: continue\n    # 重置矩阵\n    board_reset(snake, snake_size, board)\n    \n    # 如果蛇可以吃到食物，board_refresh返回true\n    # 并且board中除了蛇身(=SNAKE)，其它的元素值表示从该点运动到食物的最短路径长\n    if board_refresh(food, snake, board):\n        best_move  = find_safe_way() # find_safe_way的唯一调用处\n        f.write(\'find safe way: \' + str(best_move) + \'\\n\')\n    else:\n        best_move = follow_tail()\n        f.write(\'follow tail: \' + str(best_move) +\'\\n\')\n            \n    if best_move == ERR:\n        best_move = any_possible_move()\n        f.write(\'any possible move: \' + str(best_move) + \'\\n\')\n    # 上面一次思考，只得出一个方向，运行一步\n    if best_move != ERR: make_move(best_move)   \n    else: break        \n        \nf.close()\ncurses.endwin()\nprint("\\nScore - " + str(score)) \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  Filename:  .py    存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n', 'tags': '', 'url': 'BSnke.html'}, {'title': 'Final Project', 'text': 'Final Project 佔學期成績 30% \n Final Project 必須在 2022.01.05 22:00 之前完成 . \n Final Project 具體項目成果回報區 將於 2021.11.09 開啟, 於  2022.01.05 22:00 關閉 \n 利用 Brython 寫一個會 令人想玩 的網際遊戲. \n 參考章節: \n \n 專題摘要 \n 資料蒐集 \n 設計動機 \n 設計方法 \n 結果與討論 \n 附錄 \n \n 參考資料: \n https://github.com/collections/web-games \n https://github.com/topics/web-game \n https://github.com/topics/browser-game \n https://github.com/leereilly/games \n https://bmsleight.github.io/brython-blocks/ \n https://github.com/mdecourse/brython-blocks', 'tags': '', 'url': 'Final Project.html'}]};